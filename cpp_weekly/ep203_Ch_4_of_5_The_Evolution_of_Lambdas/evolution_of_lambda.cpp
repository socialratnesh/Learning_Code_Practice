/****************
  This example deonstrates about the features we wish lamda had has

  Chapter 4: The Evolution Of Lambdas

41: C++17's constexpr Lambda Support
128: C++20's Template Syntax for Lambdas
149: C++20's Lambda Usability Changes
171: C++20's Parameter Packs in Captures

Exercise:
What feature would you like to see added to lambdas?
Ans:

(Answer from comments on episode 203)
1. Single statement lambda is by far the best feature I'm waiting for to make
code a lot cleaner and concise: [ ] (a, b) => a < b Which can be expanded to
something like: [ ] (auto&& a, auto&& b) noexcept(a<b) -> decltype(auto) {
return a < b; }


2. Lightweight syntax, like (from proposal):
|x, y| -> x.get( y )
Which is equivalent to
[]( auto && x, auto && y ) { return x.get( y ); }


3. braced initializers for lambda type and public captures. This allows for less
restrictive use of the type generated by a lambda. Specifically it would be
useful in state-fulllambdas as you could check (or even modify) the state from
outside the lambda object or just change the initial conditions for a state-full
lambda without having to recreate the same literal expression each-time.
Example:
std::vector< decltype(
[ i = 0, j = 1 ] ( ) mutable {
return i = std::exchange( j, i + j );
}
)>      { {  }, { 5, 8 }, { .i = 1 }};


4.  would like to have ability to convert lambdas with captures into pointer functions which have 
no `void*` special closure argument where such transformation is doable with standard C++

Something which would enable a lambda to be passed to plain C `qsort` function as the comparator.

Currently that requires using libffi or similar solutions that generate executable code on the 
fly with  bound arguments (this in case of lambda) hardcoded.
It would be nice if the compiler offered this functionality so that no 3rd party libraries are required

Another useful feature would be some kind of syntax to do recursive calls in a lambda without 
any tricks with inner lambdas. Something like self_call(args...) or 
a way to name `this` of a lambda (as opposed to captured `this` of the enclosing method)


5. I would like to convert lambda to std::function without copy captured arguments. 
It terribly pisses me off. I can't capture by move any values into lambda, 
if it converts to std::function. I think we need something like std::unique_function, or 
rework std::function


 *********************/

/******
  END OF FILE
 *****/
